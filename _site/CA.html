<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ca – Analise de correspondencia</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ddd961a2510921635943dfbbd19534c4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Analise de correspondencia</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<p>Estágio 1: Objetivos da CA Os pesquisadores são constantemente confrontados com a necessidade de quantificar os dados qualitativos encontrados em variáveis nominais. A CA difere de outras técnicas MDS em sua habilidade de acomodar tanto dados nãométricos quanto relações não-lineares. Ela faz redução dimensional semelhante a escalonamento multidimensional e um tipo de mapeamento perceptual no qual as categorias são representadas no espaço multidimensional. A proximidade indica o nível de associação entre as categorias linha ou coluna. A CA pode satisfazer qualquer um dos dois objetivos básicos: 1. Associação entre somente categorias de linha ou de coluna. A CA pode ser usada para examinar a associação entre as categorias de apenas uma linha ou coluna. Um uso comum é o exame das categorias de uma escala, como a escala Likert (cinco categorias que variam de “concordo plenamente” a “discordo plenamente”) ou outras escalas qualitativas (p.ex., excelente, bom, regular, ruim). As categorias podem ser comparadas para ver se duas podem ser combinadas (isto é, elas estão muito próximas no mapa) ou se fornecem discriminação (ou seja, estão localizadas separadamente no espaço perceptual). 2. Associação entre categorias de linha e coluna. Nesta aplicação, o interesse repousa na representação da associação entre categorias das linhas e colunas, como nosso exemplo de vendas de produto por faixa etária. Esse uso é mais semelhante ao exemplo anterior de MDS e tem impelido a CA a um uso mais amplo em diversas áreas de pesquisa. O pesquisador deve determinar os objetivos específicos da análise, porque certas decisões são baseadas em qual tipo de objetivo é escolhido. A CA fornece uma representação multivariada de interdependência para dados não-métricos que não é possível com outros métodos. Com uma técnica composicional, o pesquisador deve garantir que todas as variáveis relevantes adequadas à Dimensão II Produto B Dimensão I Meia-Idade Idoso Jovens adultos Produto A Produto C FIGURA 9-11 Mapa perceptual da análise de correspondência. Análise Multivariada de Dados 512 questão de pesquisa tenham sido incluídas. Isso está em contraste com os procedimentos decomposicionais MDS descritos anteriormente, os quais exigem apenas a medida geral de similaridade. Estágio 2: Projeto de pesquisa de CA A análise de correspondência exige apenas uma matriz retangular* de dados (tabulação cruzada) de entradas não-negativas. O tipo mais comum de matriz de entrada é uma tabela de contingência com categorias específicas definindo as linhas e colunas. Ao se criar a tabela, surgem diversas questões, relativas à natureza das variáveis e categorias compreendendo linhas e colunas: 1. As linhas e colunas não têm significados pré-definidos (ou seja, os atributos não têm que ser sempre linhas e assim por diante), mas, em vez disso, representam as respostas a uma ou mais variáveis categóricas. As categorias nas linhas e colunas, porém, devem ter um significado específico para fins de interpretação. 2. As categorias para uma linha ou coluna não precisam ser uma só variável, mas podem representar qualquer conjunto de relações. Um primeiro exemplo é o método “escolha qualquer um” [14, 15], no qual é dado aos respondentes um conjunto de objetos e características. Os respondentes então indicam quais objetos, se houver algum, são descritos pelas características. O respondente pode escolher qualquer número de objetos para cada característica, e a tabela de tabulação cruzada é o número total de vezes em que cada objeto foi descrito por cada característica. 3. A tabulação cruzada pode ocorrer para mais de duas variáveis em uma forma matricial multivariada. Em tais casos, a análise de correspondência múltipla é empregada. Em um procedimento muito semelhante à análise bivariada, as variáveis adicionais são ajustadas de forma que todas as categorias são colocadas no mesmo espaço multidimensional. A natureza generalizada dos tipos de relações que podem ser retratadas na tabela de contingência torna a CA uma técnica amplamente aplicável. Seu uso crescente nos últimos anos é um resultado direto do contínuo desenvolvimento de abordagens que usam este formato para analisar novos tipos de relações. Estágio 3: Suposições em CA A análise de correspondência compartilha com as técnicas mais tradicionais de MDS uma relativa liberdade de pressupostos. O uso de dados estritamente não-métricos em sua forma mais simples (dados tabulados cruzados) representa as relações lineares e não-lineares igualmente bem. A falta de suposições, porém, não deve fazer com que o pesquisador negligencie os esforços para garantir a comparabilidade de objetos e, como essa é uma técnica composicional, a completude dos atributos usados. Estágio 4: Determinação dos resultados da CA e avaliação do ajuste geral Com uma tabela de dados cruzados, as freqüências para qualquer combinação de categorias de linhas-colunas são relacionadas com outras combinações com base nas freqüências marginais. Como descrito em nosso exemplo anterior, a análise de correspondência usa essa relação básica em três passos para criar um mapa perceptual: 1. Calcula uma expectativa condicional (a freqüência esperada de célula) que representa a similaridade ou associação entre categorias de linha e coluna. 2. Uma vez obtidas, computam-se as diferenças entre as freqüências reais e esperadas e converte-se as mesmas a uma medida padronizada (qui-quadrado). Usando-se esses resultados como uma métrica de distâncias, torna-se os mesmos comparáveis com as matrizes de entrada usadas nas abordagens MDS já discutidas. 3. Através de um processo muito parecido com o escalonamento multidimensional, cria-se uma série de soluções dimensionais (unidimensional, bidimensional etc.) sempre que possível. As dimensões relacionam simultaneamente as linhas e colunas em um único gráfico conjunto. O resultado é uma representação de categorias de linhas e/ou colunas (p.ex., marcas e atributos) no mesmo gráfico. Determinação do impacto de células individuais Deve ser observado que os dois termos específicos, desenvolvidos em análise de correspondência, descrevem as propriedades dos valores de freqüência e sua contribuição relativa à análise. • O primeiro termo é massa, que é primeiramente definido para qualquer entrada individual na tabulação cruzada como o percentual do total representado por aquela entrada. É calculado como o valor de qualquer entrada dividido por N (o total para a tabela, que é a soma das linhas ou colunas). Assim, a soma de todas as entradas da tabela (células) é igual a 1,0. Também podemos calcular a massa de qualquer categoria de linha ou coluna, somando ao longo de todas as entradas. Tal resultado representa a contribuição de qualquer categoria de linha ou coluna para a massa total. • A segunda medida é inércia, que é definida como o quiquadrado total dividido por N (o total das contagens de freqüência). Deste modo temos uma medida relativa de quiquadrado que pode ser relacionada com qualquer contagem de freqüência. Com essas semelhanças com MDS surge um conjunto parecido de problemas, centrados em duas questões fundamentais na avaliação de ajuste geral: avaliação da importância relativa das dimensões, e então a identificação do número apropriado de dimensões. Cada um desses aspectos é discutido na próxima seção. Avaliação do número de dimensões Autovalores, também conhecidos como valores singulares, são obtidos para cada dimensão e indicam a contribuição relativa de cada dimensão na explicação da variância * N. de R. T.: Seria mais adequada a expressão “de dupla entrada”, tendo em vista que tal matriz pode também ser quadrada, quando linhas e colunas apresentam o mesmo número de categorias. 513 CAPÍTULO 9 Escalonamento Multidimensional e Análise de Correspondência nas categorias. Semelhante à análise fatorial, podemos determinar a quantia de variância explicada tanto para dimensões individuais quanto para a solução como um todo. Alguns programas, como os de SPSS, introduzem uma medida chamada de inércia, que também mede variação explicada e está diretamente relacionada com o autovalor. Determinação do número de dimensões O número máximo de dimensões que pode ser estimado é um a menos do que o menor número entre a quantia de linhas ou de colunas. Por exemplo, com seis colunas e oito linhas, o número máximo de dimensões seria cinco, o que corresponde a seis (o número de colunas) menos um. O pesquisador seleciona o número de dimensões com base no nível geral de variância explicada desejada e na explicação extra ganha pelo acréscimo de uma outra dimensão. Ao avaliar dimensionalidade, o pesquisador está diante de negociações muito parecidas com outras soluções MDS ou mesmo de análise fatorial (Capítulo 3): • Cada dimensão adicionada à solução aumenta a variância explicada da solução, mas em uma quantia decrescente (ou seja, a primeira dimensão explica a maior parte da variância, a segunda explica a segunda maior parte, e assim por diante). • Adicionar dimensões aumenta a complexidade do processo de interpretação; mapas perceptuais com mais de três dimensões se tornam cada vez mais complexos para análise. O pesquisador deve equilibrar o desejo por variância explicada maior versus a solução mais complexa que possa afetar a interpretação. Uma dica prática é que dimensões com inércia (autovalores) maiores que 0,2 devem ser incluídas na análise. Estimação do modelo Vários programas de computador estão à disposição para realizar a análise de correspondência. Entre os programas mais populares, estão ANACOR e HOMALS, disponíveis no SPSS; CA de BMDP; CORRAN e CORRESP de PC-MDS [24]; e MAPWISE [21]. Um grande número de aplicações especializadas tem surgido em disciplinas específicas como ecologia, geologia e muitas das ciências sociais. Estágio 5: Interpretação dos resultados Logo que a dimensionalidade tiver sido estabelecida, o pesquisador se defronta com duas tarefas: interpretar as dimensões para compreender a base para a associação entre categorias e avaliar o grau de associação entre categorias, dentro de uma linha/coluna ou entre linhas e colunas. Fazendo isso, o pesquisador ganha uma compreensão a respeito das dimensões inerentes sobre as quais o mapa perceptual se baseia, juntamente com a associação derivada de qualquer conjunto específico de categorias. Definição do caráter das dimensões Se o pesquisador está interessado em definir o caráter de uma ou mais dimensões em termos das categorias de linha ou coluna, medidas descritivas em cada programa de computador indicam a associação de cada categoria a uma dimensão específica. Por exemplo, em SPSS a medida de inércia (usada para avaliar o grau de variância explicada) é decomposta ao longo das dimensões. Semelhantes, em caráter, a cargas fatoriais, esses valores representam a extensão da associação para cada categoria individualmente com cada dimensão. O pesquisador pode então nomear cada dimensão em termos das categorias mais associadas com ela. Além de representar a associação de cada categoria com cada dimensão, os valores de inércia podem ser totalizados ao longo de dimensões em uma medida coletiva. Fazendo isso, ganhamos uma medida empírica do grau em que cada categoria está representada ao longo de todas as dimensões. Conceitualmente, esta medida é similar à medida de comunalidade de análise fatorial (ver Capítulo 3). Avaliação da associação entre categorias A segunda tarefa na interpretação é identificar a associação de uma categoria com outras, o que pode ser feito visualmente ou por meio de medidas empíricas. Qualquer que seja a técnica empregada, o pesquisador deve primeiramente escolher os tipos de comparação a serem feitas e então a normalização adequada para a comparação selecionada. Os dois tipos de comparação são: 1. Entre categorias da mesma linha ou coluna. Aqui o foco é apenas sobre linhas ou colunas, como quando se examinam as categorias de uma escala para ver se elas podem ser combinadas. Esses tipos de comparações podem ser feitos diretamente a partir de qualquer análise de correspondência. 2. Entre linhas e colunas. Uma tentativa de relacionar a associação entre uma categoria de linha e uma de coluna. Este tipo mais comum de comparação relaciona categorias ao longo de dimensões (como em nosso exemplo anterior, vendas de produtos associadas com categorias etárias). Contudo, desta vez há algum debate na adequação da comparação entre categorias de linha e de coluna. Em um sentido estrito, distâncias entre pontos representando categorias só podem ser feitas dentro de uma linha ou coluna. É considerada inadequada a comparação direta de uma categoria de linha e uma de coluna. É apropriado fazer generalizações referentes às dimensões e à posição de cada categoria sobre tais dimensões. Assim, a posição relativa de categorias de linha e coluna pode ser definida dentro dessas dimensões, mas não deve haver comparação direta. Alguns programas de computador fornecem um procedimento de normalização para viabilizar essa comparação direta. Se apenas um procedimento de normalização de linha ou coluna está disponível, técnicas alternativas são propostas para tornar todas as categorias comparáveis [2, 21], mas ainda há discordâncias quanto ao seu sucesso [12]. Nos casos em que as comparações diretas não são possíveis, a Análise Multivariada de Dados 514 correspondência geral ainda vale e padrões específicos podem ser distinguidos. Os objetivos da pesquisa podem se concentrar na avaliação das dimensões ou na comparação de categorias, e o pesquisador é encorajado a fazer ambas as interpretações já que elas reforçam uma a outra. Por exemplo, a comparação de categorias de linha versus de coluna sempre pode ser complementada com a compreensão da natureza das dimensões para fornecer uma perspectiva mais abrangente do posicionamento das categorias em vez de simplesmente comparações específicas. Analogamente, a avaliação da comparação específica de categorias pode dar especificidade à interpretação das dimensões. Estágio 6: Validação dos resultados A natureza composicional da análise de correspondência fornece maior especificidade para o pesquisador validar os resultados. Fazendo isso, o pesquisador deve buscar avaliar duas questões-chave relativas à generalidade de dois elementos: • Amostra. Como ocorre com todas as técnicas MDS, deve-se enfatizar a garantia da generalidade por meio de análises de subamostras ou múltiplas amostras. • Objetos. A generalidade dos objetos (representada individualmente e como um conjunto pelas categorias) também deve ser estabelecida. A sensibilidade dos resultados à adição ou eliminação de uma categoria pode ser avaliada. A meta é avaliar se a análise depende de apenas poucos objetos e/ou atributos. Em qualquer caso, o pesquisador deve entender o verdadeiro significado dos resultados em termos das categorias sendo analisadas. A natureza inferencial da análise de correspondência, como outros métodos MDS, requer estrita confiança na representatividade e generalidade da amostra de respondentes e objetos (categorias) sob análise. Visão geral da análise de correspondência A análise de correspondência apresenta ao pesquisador diversas vantagens, variando da natureza generalizada dos dados de entrada ao desenvolvimento de mapas perceptuais únicos: • A simples tabulação cruzada de múltiplas variáveis categóricas, como atributos de produtos versus marcas, pode ser representada em um espaço perceptual. Essa abordagem permite ao pesquisador analisar as respostas existentes ou reunir respostas no tipo menos restritivo de medida, o nível categórico ou nominal. Por exemplo, o respondente precisa avaliar somente com respostas do tipo sim ou não um conjunto de objetos quanto a alguns atributos. Essas respostas podem então ser agregadas em uma tabela cruzada e analisadas. Outras técnicas, como a análise fatorial, exigem avaliações na escala intervalar de cada atributo para cada objeto. • A CA retrata não somente as relações entre as linhas e colunas, mas também as relações entre as categorias de linhas ou colunas. Por exemplo, se as colunas fossem atributos, múltiplos atributos próximos teriam perfis similares ao longo de produtos, formando um grupo de atributos muito semelhante a um fator de análise de componentes principais. • A CA pode fornecer uma visão conjunta de categorias das linhas e colunas na mesma dimensionalidade. Certas modificações de programas permitem comparações entre pontos nos quais a proximidade relativa está diretamente relacionada com a maior associação entre pontos separados [1, 21]. Quando essas comparações são possíveis, permitem que categorias das linhas e colunas sejam examinadas simultaneamente. Uma análise desse tipo capacitaria o pesquisador a identificar grupos de produtos caracterizados por atributos em grande proximidade. Junto com as vantagens da CA, porém, surgem algumas desvantagens ou limitações. • A técnica é descritiva e nada adequada ao teste de hipóteses. Se a relação quantitativa de categorias é desejada, métodos como modelos log-lineares são sugeridos. A CA é mais adequada à análise exploratória de dados. • A CA, como acontece com muitos métodos de redução de dimensionalidade, não dispõe de procedimento para determinar conclusivamente o número apropriado de dimensões. Como ocorre com métodos similares, o pesquisador deve equilibrar interpretabilidade com parcimônia da representação dos dados. Análise de correspondência • A análise de correspondência (CA) é mais adequada para pesquisa exploratória e não é adequada para teste de hipóteses • A CA é uma forma de técnica composicional que demanda especificação de objetos e atributos a serem comparados • A análise de correspondência é sensível a observações atípicas, as quais devem ser eliminadas antes de se usar tal técnica • O número de dimensões a serem mantidas na solução se baseia em: • Dimensões com inércia (autovalores) maiores que 0,2 • Dimensões suficientes para atender os objetivos da pesquisa (geralmente duas ou três) • Dimensões podem ser “nomeadas” com base na decomposição de medidas de inércia ao longo de uma dimensão: • Esses valores mostram a extensão de associação para cada categoria individualmente com cada dimensão • Elas podem ser usadas para descrição como as cargas em análise fatorial REGRAS PRÁTICAS 9-4 515 CAPÍTULO 9 Escalonamento Multidimensional e Análise de Correspondência • A técnica é bastante sensível a dados atípicos, em termos de linhas ou colunas (p.ex., atributos ou marcas). Além disso, para fins de generalização, o problema de objetos ou atributos omitidos é crítico. No geral, a análise de correspondência provê uma valiosa ferramenta analítica para um tipo de dado (não-métrico) que normalmente não é o ponto focal de técnicas multivariadas. A análise de correspondência também fornece ao pesquisador uma técnica composicional complementar ao MDS, para tratar de questões nas quais a comp</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>