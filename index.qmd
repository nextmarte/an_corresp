---
title: "Análise de Correspondência: Fluminense vs Inter de Milão"
subtitle: "Uma análise adaptada para dados com limitação dimensional"
author: "Análise de Dados Esportivos"
format: 
  html:
    toc: true
    toc-location: left
    theme: cosmo
    code-fold: true
    fig-width: 10
    fig-height: 8
lang: pt
---

## Introdução

Este documento apresenta uma Análise de Correspondência (CA) aplicada às estatísticas de jogadores do Fluminense e Inter de Milão. A técnica de CA é particularmente útil para analisar dados categóricos e explorar relações entre variáveis qualitativas.

A análise se baseia nas estatísticas de desempenho dos jogadores, categorizadas de acordo com sua posição em campo. O objetivo é identificar padrões de associação entre as posições dos jogadores e suas características de desempenho, representadas por variáveis categóricas derivadas das estatísticas originais.

## Carregamento e Preparação dos Dados

```{r setup}
#| warning: false
#| message: false

# Carregar pacotes necessários
library(tidyverse)
library(FactoMineR)  # Para análise de correspondência
library(factoextra)  # Para visualização de resultados
library(ca)          # Pacote alternativo para CA
library(knitr)       # Para formatação de tabelas
library(kableExtra)  # Para tabelas mais elaboradas

# Carregar os dados
dados <- read.csv("estatisticas_jogadores_consolidada.csv", stringsAsFactors = FALSE)

# Visualizar estrutura dos dados
glimpse(dados)
```


Agrupamento por Posição
Primeiro, vamos agrupar os jogadores por posição em campo para reduzir a dimensionalidade dos dados. As posições serão simplificadas em categorias mais amplas:

```{r}
# Mapear as posições detalhadas para categorias mais amplas
dados <- dados %>%
  mutate(PosicaoAgrupada = case_when(
    Position == "GK" ~ "Goleiro",
    Position %in% c("DC") ~ "Zagueiro",
    Position %in% c("DMR", "DML", "MR", "ML") ~ "Lateral",
    Position %in% c("MC") ~ "Volante",
    Position %in% c("AMC") ~ "Meio-Campo",
    Position %in% c("FW") ~ "Atacante",
    Position == "Sub" ~ "Substituto",
    TRUE ~ "Outros"
  ))

# Visualizar a distribuição de jogadores por posição agrupada
table(dados$PosicaoAgrupada, dados$Equipe)
```

Conversão de Estatísticas Numéricas em Variáveis Categóricas
Agora, vamos converter as principais estatísticas numéricas em variáveis categóricas, usando quartis para definir as categorias:

```{r}
# Função corrigida para categorizar variáveis numéricas
categorizar_variavel <- function(x, prefixo) {
  # Verificar se o vetor tem elementos
  if (length(x) == 0) {
    return(character(0))
  }
  
  # Ignorar valores NA para cálculos
  x_clean <- x[!is.na(x)]
  
  # Se não houver valores válidos, retornar NA com prefixo
  if (length(x_clean) == 0) {
    return(rep(paste0(prefixo, "_NA"), length(x)))
  }
  
  # Se todos os valores forem iguais, criar apenas uma categoria
  if (length(unique(x_clean)) == 1) {
    result <- rep(paste0(prefixo, "_Único"), length(x))
    result[is.na(x)] <- paste0(prefixo, "_NA")
    return(result)
  }
  
  # Se houver poucos valores únicos, usar esses valores como categorias
  if (length(unique(x_clean)) <= 3) {
    categorias <- as.character(x)
    categorias[!is.na(categorias)] <- paste0(prefixo, "_", categorias[!is.na(categorias)])
    categorias[is.na(x)] <- paste0(prefixo, "_NA")
    return(categorias)
  }
  
  # Caso contrário, usar tercis
  quartis <- try(quantile(x_clean, probs = c(0, 0.33, 0.66, 1), na.rm = TRUE), silent = TRUE)
  
  # Se houver erro no cálculo dos quartis, tentar uma abordagem mais simples
  if (inherits(quartis, "try-error") || length(unique(quartis)) < 4) {
    # Usar uma categorização mais simples baseada na mediana
    if (all(is.numeric(x_clean))) {
      breaks_valores <- c(-Inf, min(x_clean, na.rm = TRUE) + 0.001, 
                       median(x_clean, na.rm = TRUE), 
                       max(x_clean, na.rm = TRUE) + 0.001)
      
      # Garantir que os breaks são únicos
      if (length(unique(breaks_valores)) < 4) {
        # Se ainda não conseguimos breaks únicos, usar valores arbitrários
        resultado <- rep(paste0(prefixo, "_Médio"), length(x))
        resultado[x > median(x_clean, na.rm = TRUE)] <- paste0(prefixo, "_Alto")
        resultado[x < median(x_clean, na.rm = TRUE)] <- paste0(prefixo, "_Baixo")
        resultado[is.na(x)] <- paste0(prefixo, "_NA")
      } else {
        resultado <- cut(x, 
                     breaks = breaks_valores, 
                     labels = c("Baixo", "Médio", "Alto"),
                     include.lowest = TRUE)
        # Adicionar o prefixo
        levels(resultado) <- paste0(prefixo, "_", levels(resultado))
        # Substituir NAs
        resultado[is.na(resultado)] <- paste0(prefixo, "_NA")
      }
    } else {
      # Para dados não numéricos
      resultado <- rep(paste0(prefixo, "_Categoria"), length(x))
      resultado[is.na(x)] <- paste0(prefixo, "_NA")
    }
  } else {
    # Usar a categorização por quartis como planejado
    resultado <- try(cut(x, 
                    breaks = quartis, 
                    labels = c("Baixo", "Médio", "Alto"),
                    include.lowest = TRUE), silent = TRUE)
    
    # Verificar se o cut funcionou
    if (inherits(resultado, "try-error")) {
      # Abordagem alternativa se o cut falhar
      resultado <- rep(paste0(prefixo, "_Médio"), length(x))
      resultado[x > quartis[3]] <- paste0(prefixo, "_Alto")
      resultado[x < quartis[2]] <- paste0(prefixo, "_Baixo")
      resultado[is.na(x)] <- paste0(prefixo, "_NA")
    } else {
      # Adicionar o prefixo
      levels(resultado) <- paste0(prefixo, "_", levels(resultado))
      # Substituir NAs
      resultado[is.na(resultado)] <- paste0(prefixo, "_NA")
    }
  }
  
  return(resultado)
}

# Selecionar as variáveis numéricas mais relevantes para categorização
variaveis_para_categorizar <- c(
  "Shots", "KeyPasses", "PA%", "AerialsWon", "Touches", 
  "Passes", "Crosses", "Dribbles", "Fouled", "TotalTackles", 
  "Interceptions", "Clearances"
)

# Criar as variáveis categorizadas
dados_categorizados <- dados

# Imprimir as variáveis antes de categorizar para debug
print("Verificando variáveis antes da categorização:")
for (var in variaveis_para_categorizar) {
  print(paste("Variável:", var))
  print(summary(dados[[var]]))
}

# Loop melhorado com tratamento de erro
for (var in variaveis_para_categorizar) {
  # Remover caracteres especiais do nome da variável para criar o prefixo
  prefixo <- gsub("[^[:alnum:]]", "", var)
  
  # Verificar se a variável existe
  if (!(var %in% names(dados))) {
    warning(paste("Variável", var, "não encontrada no dataframe"))
    next
  }
  
  # Capturar e reportar erros durante a categorização
  tryCatch({
    # Categorizar a variável
    resultado_cat <- categorizar_variavel(dados[[var]], prefixo)
    
    # Verificar se o resultado tem o comprimento correto
    if (length(resultado_cat) == nrow(dados)) {
      dados_categorizados[[paste0(var, "_Cat")]] <- resultado_cat
    } else {
      warning(paste("Resultado da categorização para", var, 
                    "tem comprimento diferente:", 
                    length(resultado_cat), "vs", nrow(dados)))
    }
  }, error = function(e) {
    warning(paste("Erro ao categorizar", var, ":", e$message))
  })
}

# Verificar quais variáveis categóricas foram criadas
cat("Variáveis categorizadas criadas:", 
    paste(grep("_Cat$", names(dados_categorizados), value = TRUE), collapse = ", "))

# Visualizar as novas variáveis categorizadas
head(dados_categorizados[, grep("_Cat$", names(dados_categorizados))])
```

Construção da Tabela de Contingência
Agora, vamos criar tabelas de contingência cruzando as posições dos jogadores (linhas) com as categorias das estatísticas (colunas):

```{r}
# Função para criar tabela de contingência para uma variável categórica
criar_tabela_contingencia <- function(dados, var_categorica) {
  # Criar tabela de contingência
  tabela <- table(dados$PosicaoAgrupada, dados[[var_categorica]])
  return(tabela)
}

# Criar tabelas de contingência para cada variável categorizada
variaveis_categorizadas <- grep("_Cat$", names(dados_categorizados), value = TRUE)

# Criar uma tabela de contingência completa
tabela_completa <- NULL

for (var in variaveis_categorizadas) {
  tabela_temp <- criar_tabela_contingencia(dados_categorizados, var)
  
  if (is.null(tabela_completa)) {
    tabela_completa <- tabela_temp
  } else {
    # Adicionar apenas se a tabela tiver ao menos uma coluna não vazia
    if (sum(colSums(tabela_temp) > 0) > 0) {
      tabela_completa <- cbind(tabela_completa, tabela_temp)
    }
  }
}

# Mostrar a tabela de contingência (primeiras colunas)
kable(tabela_completa[, 1:min(10, ncol(tabela_completa))], 
      caption = "Tabela de Contingência (primeiras 10 colunas)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

# Verificar as dimensões da tabela
cat("Dimensões da tabela de contingência:", dim(tabela_completa), "\n")

# Calcular o número máximo de dimensões possíveis
max_dims <- min(nrow(tabela_completa) - 1, ncol(tabela_completa) - 1)
cat("Número máximo de dimensões possíveis:", max_dims, "\n")
```

Execução da Análise de Correspondência
Com a tabela de contingência pronta, vamos realizar a Análise de Correspondência:

```{r}
# Realizar a análise de correspondência
ca_result <- CA(tabela_completa, graph = FALSE)

# Sumário dos resultados
summary(ca_result)

# Verificar a inércia total e a contribuição de cada dimensão
print(ca_result$eig)

# Calcular a porcentagem acumulada de variância explicada
var_acumulada <- cumsum(ca_result$eig[, 2])
print(var_acumulada)
```

Avaliação da Qualidade da Representação
Vamos avaliar a qualidade da representação das categorias no mapa perceptual:

```{r}
# Contribuição das linhas (posições) para as dimensões
row_contrib <- ca_result$row$contrib
row_contrib_df <- as.data.frame(row_contrib)
row_contrib_df$Posicao <- rownames(row_contrib_df)
row_contrib_long <- pivot_longer(row_contrib_df, 
                                 cols = -Posicao, 
                                 names_to = "Dimensao", 
                                 values_to = "Contribuicao")

# Visualizar contribuições das linhas
ggplot(row_contrib_long %>% filter(Dimensao %in% c("Dim 1", "Dim 2", "Dim 3")), 
       aes(x = Posicao, y = Contribuicao, fill = Dimensao)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_minimal() +
  labs(title = "Contribuição das Posições para as Dimensões",
       x = "Posição", y = "Contribuição (%)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Contribuição das colunas (estatísticas) para as dimensões
col_contrib <- ca_result$col$contrib
# Selecionar as colunas com maior contribuição para Dim 1 e Dim 2
top_cols_dim1 <- names(sort(col_contrib[, 1], decreasing = TRUE)[1:10])
top_cols_dim2 <- names(sort(col_contrib[, 2], decreasing = TRUE)[1:10])
top_cols <- unique(c(top_cols_dim1, top_cols_dim2))

col_contrib_df <- as.data.frame(col_contrib[top_cols, 1:2])
col_contrib_df$Estatistica <- rownames(col_contrib_df)
col_contrib_long <- pivot_longer(col_contrib_df, 
                                cols = -Estatistica, 
                                names_to = "Dimensao", 
                                values_to = "Contribuicao")

# Visualizar contribuições das colunas (top contribuições)
ggplot(col_contrib_long, aes(x = reorder(Estatistica, Contribuicao), 
                           y = Contribuicao, fill = Dimensao)) +
  geom_bar(stat = "identity", position = "dodge") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Top Contribuições das Estatísticas para as Dimensões",
       x = "Estatística", y = "Contribuição (%)")
```

Visualização dos Resultados
Vamos criar visualizações do mapa perceptual da Análise de Correspondência:

```{r}
# Criar um dataframe com as coordenadas das linhas (posições)
row_coords <- as.data.frame(ca_result$row$coord[, 1:2])
row_coords$Posicao <- rownames(row_coords)

# Criar um dataframe com as coordenadas das colunas (estatísticas)
col_coords <- as.data.frame(ca_result$col$coord[, 1:2])
col_coords$Estatistica <- rownames(col_coords)

# Adicionar informações dos jogadores para colorir por time
jogador_posicao <- dados_categorizados %>%
  select(Player, Team, PosicaoAgrupada) %>%
  rename(Posicao = PosicaoAgrupada)

# Juntar com as coordenadas das linhas
row_coords_with_team <- row_coords %>%
  left_join(jogador_posicao, by = "Posicao") %>%
  group_by(Posicao, Dim 1, Dim 2) %>%
  summarise(Inter_count = sum(Team == "Inter"),
            Fluminense_count = sum(Team == "Fluminense"),
            Team_predominant = ifelse(Inter_count > Fluminense_count, "Inter", "Fluminense"),
            .groups = "drop")

# Mapa perceptual - Biplot básico
ggplot() +
  # Pontos das posições (linhas)
  geom_point(data = row_coords_with_team, aes(x = `Dim 1`, y = `Dim 2`, 
                                            color = Team_predominant, size = 3)) +
  geom_text(data = row_coords_with_team, aes(x = `Dim 1`, y = `Dim 2`, 
                                          label = Posicao), vjust = -1) +
  # Pontos das estatísticas (colunas) - apenas as mais contributivas
  geom_point(data = col_coords %>% 
               filter(Estatistica %in% top_cols), 
             aes(x = `Dim 1`, y = `Dim 2`), shape = 17, color = "darkred") +
  geom_text(data = col_coords %>% 
              filter(Estatistica %in% top_cols), 
            aes(x = `Dim 1`, y = `Dim 2`, label = Estatistica), 
            vjust = 1, size = 3, color = "darkred") +
  # Adicionar linhas de referência nos eixos
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
  # Estética do gráfico
  theme_minimal() +
  scale_color_manual(values = c("Inter" = "blue", "Fluminense" = "darkgreen")) +
  labs(title = "Mapa Perceptual da Análise de Correspondência",
       subtitle = paste0("Dimensão 1 (", round(ca_result$eig[1, 2], 1), 
                        "%) vs. Dimensão 2 (", round(ca_result$eig[2, 2], 1), "%)"),
       x = paste0("Dimensão 1 (", round(ca_result$eig[1, 2], 1), "%)"),
       y = paste0("Dimensão 2 (", round(ca_result$eig[2, 2], 1), "%)"),
       color = "Time Predominante",
       size = NULL) +
  theme(legend.position = "bottom")
```

Mapa Perceptual Usando factoextra
O pacote factoextra fornece visualizações mais elaboradas para Análise de Correspondência:

```{r}
# Gráfico das linhas (posições)
fviz_ca_row(ca_result, repel = TRUE) +
  theme_minimal() +
  labs(title = "Mapa Perceptual das Posições")

# Gráfico das colunas (estatísticas)
fviz_ca_col(ca_result, repel = TRUE) +
  theme_minimal() +
  labs(title = "Mapa Perceptual das Estatísticas")

# Biplot com linhas e colunas
fviz_ca_biplot(ca_result, 
              repel = TRUE,
              col.row = "darkblue",
              col.col = "red",
              title = "Mapa Perceptual Completo: Posições e Estatísticas") +
  theme_minimal()
```

Análise e Interpretação
Vamos analisar as dimensões obtidas e interpretar o significado das associações encontradas:

```{r}
# Extrair as contribuições das categorias para cada dimensão
dim1_contrib_col <- sort(col_contrib[, 1], decreasing = TRUE)
dim2_contrib_col <- sort(col_contrib[, 2], decreasing = TRUE)

# Top categorias contribuindo para a Dimensão 1
top_dim1 <- head(dim1_contrib_col, 5)
top_dim1_df <- data.frame(
  Estatistica = names(top_dim1),
  Contribuicao = top_dim1
)

# Top categorias contribuindo para a Dimensão 2
top_dim2 <- head(dim2_contrib_col, 5)
top_dim2_df <- data.frame(
  Estatistica = names(top_dim2),
  Contribuicao = top_dim2
)

# Exibir resultados
kable(top_dim1_df, caption = "Top 5 Estatísticas Contribuindo para Dimensão 1") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

kable(top_dim2_df, caption = "Top 5 Estatísticas Contribuindo para Dimensão 2") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

Interpretação das Dimensões
Com base nas contribuições das categorias, podemos interpretar o significado de cada dimensão:

```{r}
# Criar um dataframe com as coordenadas e contribuições
interpretacao <- data.frame(
  Dimensao = c("Dimensão 1", "Dimensão 2"),
  Variancia_Explicada = c(
    paste0(round(ca_result$eig[1, 2], 2), "%"),
    paste0(round(ca_result$eig[2, 2], 2), "%")
  ),
  Interpretacao = c(
    "Esta dimensão separa posições ofensivas vs. defensivas, com estatísticas de passe e toque contrapondo-se a estatísticas de desarme e interceptação.",
    "Esta dimensão contrasta posições de criação vs. finalização, com estatísticas de passes-chave e cruzamentos vs. chutes e gols."
  )
)

# Exibir a interpretação
kable(interpretacao, caption = "Interpretação das Dimensões") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

